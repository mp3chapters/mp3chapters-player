{"version":3,"file":"vendors-node_modules_vidstack_dist_dev_providers_vidstack-youtube_js.bundle.js","mappings":";;;;;;;;;;;;;;;;AAAoI;AACpE;;AAEhE;AACA,kBAAkB,wDAAe;AACjC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,wDAAM;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY,iBAAiB,oBAAoB,eAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wDAAM;AACV,IAAI,wDAAW;AACf,IAAI,wDAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAI;AACvB,qCAAqC,wDAAiB;AACtD;AACA;AACA;AACA;AACA;AACA,wGAAwG,wDAAQ;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEiD;;;;;;;;;;;;;;;;;;;ACpEmH;AACpG;AACC;AACsB;AAC/C;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,2DAAa;AAC3C;AACA;AACA;AACA,iBAAiB,+DAAW;AAC5B,oBAAoB,+DAAM;AAC1B;AACA;AACA;AACA,4BAA4B,2DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kIAAkI,GAAG;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+DAAU;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAM;AACV,IAAI,+DAAM;AACV;AACA;AACA;AACA,YAAY,SAAS;AACrB,SAAS,+DAAI;AACb;AACA;AACA,0BAA0B,+DAAY;AACtC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,QAAQ,+DAAI;AACZ;AACA;AACA,2BAA2B,+DAAY;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,+DAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB,SAAS,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,kCAAkC,wBAAwB,GAAG,QAAQ,GAAG,KAAK,GAAG,KAAK;AACrF;AACA;AACA,YAAY,cAAc,sBAAsB,eAAe,eAAe,+BAA+B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC;AACA,sFAAsF,2DAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAS;AAC7B;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,YAAY,gCAAgC;AAC5C,QAAQ,+DAAQ;AAChB;AACA;AACA,QAAQ,+DAAQ;AAChB,UAAU,+DAAQ;AAClB,gHAAgH,2DAAS;AACzH;AACA;AACA;AACA;AACA,QAAQ,+DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,mCAAmC,2DAAS;AAC5C;AACA;AACA;AACA;AACA,QAAQ,+DAAQ,iBAAiB,+DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAS;AACrC;AACA;AACA;AACA;;AAE2B","sources":["webpack://mp3chapters-player/./node_modules/vidstack/dist/dev/chunks/vidstack-ZED4myhE.js","webpack://mp3chapters-player/./node_modules/vidstack/dist/dev/providers/vidstack-youtube.js"],"sourcesContent":["import { v as deferredPromise, m as signal, e as effect, l as listenEvent, p as peek, r as isString } from './vidstack-KTx0QncX.js';\nimport { a as appendParamsToURL } from './vidstack-Yx-0ZQdX.js';\n\nfunction timedPromise(callback, ms = 3e3) {\n  const promise = deferredPromise();\n  setTimeout(() => {\n    const rejection = callback();\n    if (rejection)\n      promise.reject(rejection);\n  }, ms);\n  return promise;\n}\n\nclass EmbedProvider {\n  constructor(_iframe) {\n    this._iframe = _iframe;\n    this._src = signal(\"\");\n    /**\n     * Defines which referrer is sent when fetching the resource.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy}\n     */\n    this.referrerPolicy = null;\n    _iframe.setAttribute(\"frameBorder\", \"0\");\n    _iframe.setAttribute(\n      \"allow\",\n      \"autoplay; fullscreen; encrypted-media; picture-in-picture; accelerometer; gyroscope\"\n    );\n    if (this.referrerPolicy !== null) {\n      _iframe.setAttribute(\"referrerpolicy\", this.referrerPolicy);\n    }\n  }\n  get iframe() {\n    return this._iframe;\n  }\n  setup(ctx) {\n    effect(this._watchSrc.bind(this));\n    listenEvent(window, \"message\", this._onWindowMessage.bind(this));\n    listenEvent(this._iframe, \"load\", this._onLoad.bind(this));\n  }\n  _watchSrc() {\n    const src = this._src();\n    if (!src.length) {\n      this._iframe.setAttribute(\"src\", \"\");\n      return;\n    }\n    const params = peek(() => this._buildParams());\n    this._iframe.setAttribute(\"src\", appendParamsToURL(src, params));\n  }\n  _postMessage(message, target) {\n    this._iframe.contentWindow?.postMessage(JSON.stringify(message), target ?? \"*\");\n  }\n  _onWindowMessage(event) {\n    const origin = this._getOrigin(), isOriginMatch = event.source === this._iframe?.contentWindow && (!isString(origin) || origin === event.origin);\n    if (!isOriginMatch)\n      return;\n    try {\n      const message = JSON.parse(event.data);\n      if (message)\n        this._onMessage(message, event);\n      return;\n    } catch (e) {\n    }\n    if (event.data)\n      this._onMessage(event.data, event);\n  }\n}\n\nexport { EmbedProvider as E, timedPromise as t };\n","import { q as createScope, m as signal, e as effect, p as peek, r as isString, t as isObject, a as isNumber, u as isBoolean } from '../chunks/vidstack-KTx0QncX.js';\nimport { T as TimeRange } from '../chunks/vidstack-DTSGQ87h.js';\nimport { p as preconnect } from '../chunks/vidstack-Yx-0ZQdX.js';\nimport { E as EmbedProvider, t as timedPromise } from '../chunks/vidstack-ZED4myhE.js';\nimport '../chunks/vidstack-S5-ZnP-2.js';\n\nconst YouTubePlayerState = {\n  _Unstarted: -1,\n  _Ended: 0,\n  _Playing: 1,\n  _Paused: 2,\n  _Buffering: 3,\n  _Cued: 5\n};\n\nclass YouTubeProvider extends EmbedProvider {\n  constructor() {\n    super(...arguments);\n    this.$$PROVIDER_TYPE = \"YOUTUBE\";\n    this.scope = createScope();\n    this._videoId = signal(\"\");\n    this._state = -1;\n    this._seekingTimer = -1;\n    this._played = 0;\n    this._playedRange = new TimeRange(0, 0);\n    this._currentSrc = null;\n    this._playPromise = null;\n    this._pausePromise = null;\n    /**\n     * Sets the player's interface language. The parameter value is an ISO 639-1 two-letter\n     * language code or a fully specified locale. For example, fr and fr-ca are both valid values.\n     * Other language input codes, such as IETF language tags (BCP 47) might also be handled properly.\n     *\n     * The interface language is used for tooltips in the player and also affects the default caption\n     * track. Note that YouTube might select a different caption track language for a particular\n     * user based on the user's individual language preferences and the availability of caption tracks.\n     *\n     * @defaultValue 'en'\n     */\n    this.language = \"en\";\n    this.color = \"red\";\n    /**\n     * Whether cookies should be enabled on the embed. This is turned off by default to be\n     * GDPR-compliant.\n     *\n     * @defaultValue `false`\n     */\n    this.cookies = false;\n  }\n  static {\n    this._videoIdRE = /(?:youtu\\.be|youtube|youtube\\.com|youtube-nocookie\\.com)\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=|)((?:\\w|-){11})/;\n  }\n  static {\n    this._posterCache = /* @__PURE__ */ new Map();\n  }\n  get _notify() {\n    return this._ctx.delegate._notify;\n  }\n  get currentSrc() {\n    return this._currentSrc;\n  }\n  get type() {\n    return \"youtube\";\n  }\n  get videoId() {\n    return this._videoId();\n  }\n  preconnect() {\n    const connections = [\n      this._getOrigin(),\n      // Botguard script.\n      \"https://www.google.com\",\n      // Poster.\n      \"https://i.ytimg.com\",\n      // Ads.\n      \"https://googleads.g.doubleclick.net\",\n      \"https://static.doubleclick.net\"\n    ];\n    for (const url of connections) {\n      preconnect(url, \"preconnect\");\n    }\n  }\n  setup(ctx) {\n    this._ctx = ctx;\n    super.setup(ctx);\n    effect(this._watchVideoId.bind(this));\n    effect(this._watchPoster.bind(this));\n    this._notify(\"provider-setup\", this);\n  }\n  async play() {\n    const { paused } = this._ctx.$state;\n    if (!peek(paused))\n      return;\n    if (!this._playPromise) {\n      this._playPromise = timedPromise(() => {\n        this._playPromise = null;\n        if (paused())\n          return \"Timed out.\";\n      });\n      this._remote(\"playVideo\");\n    }\n    return this._playPromise.promise;\n  }\n  async pause() {\n    const { paused } = this._ctx.$state;\n    if (peek(paused))\n      return;\n    if (!this._pausePromise) {\n      this._pausePromise = timedPromise(() => {\n        this._pausePromise = null;\n        if (!paused())\n          ;\n      });\n      this._remote(\"pauseVideo\");\n    }\n    return this._pausePromise.promise;\n  }\n  setMuted(muted) {\n    if (muted)\n      this._remote(\"mute\");\n    else\n      this._remote(\"unMute\");\n  }\n  setCurrentTime(time) {\n    this._remote(\"seekTo\", time);\n  }\n  setVolume(volume) {\n    this._remote(\"setVolume\", volume * 100);\n  }\n  setPlaybackRate(rate) {\n    this._remote(\"setPlaybackRate\", rate);\n  }\n  async loadSource(src) {\n    if (!isString(src.src)) {\n      this._currentSrc = null;\n      this._videoId.set(\"\");\n      return;\n    }\n    const videoId = src.src.match(YouTubeProvider._videoIdRE)?.[1];\n    this._videoId.set(videoId ?? \"\");\n    this._currentSrc = src;\n  }\n  _getOrigin() {\n    return !this.cookies ? \"https://www.youtube-nocookie.com\" : \"https://www.youtube.com\";\n  }\n  _watchVideoId() {\n    this._reset();\n    const videoId = this._videoId();\n    if (!videoId) {\n      this._src.set(\"\");\n      return;\n    }\n    this._src.set(`${this._getOrigin()}/embed/${videoId}`);\n  }\n  _watchPoster() {\n    const videoId = this._videoId(), cache = YouTubeProvider._posterCache;\n    if (!videoId)\n      return;\n    if (cache.has(videoId)) {\n      const url = cache.get(videoId);\n      this._notify(\"poster-change\", url);\n      return;\n    }\n    const abort = new AbortController();\n    this._findPoster(videoId, abort);\n    return () => {\n      abort.abort();\n    };\n  }\n  async _findPoster(videoId, abort) {\n    try {\n      const sizes = [\"maxresdefault\", \"sddefault\", \"hqdefault\"];\n      for (const size of sizes) {\n        for (const webp of [true, false]) {\n          const url = this._resolvePosterURL(videoId, size, webp), response = await fetch(url, {\n            mode: \"no-cors\",\n            signal: abort.signal\n          });\n          if (response.status < 400) {\n            YouTubeProvider._posterCache.set(videoId, url);\n            this._notify(\"poster-change\", url);\n            return;\n          }\n        }\n      }\n    } catch (e) {\n    }\n    this._notify(\"poster-change\", \"\");\n  }\n  _resolvePosterURL(videoId, size, webp) {\n    const type = webp ? \"webp\" : \"jpg\";\n    return `https://i.ytimg.com/${webp ? \"vi_webp\" : \"vi\"}/${videoId}/${size}.${type}`;\n  }\n  _buildParams() {\n    const { keyDisabled } = this._ctx.$props, { $iosControls } = this._ctx, { controls, muted, playsinline } = this._ctx.$state, showControls = controls() || $iosControls();\n    return {\n      autoplay: 0,\n      cc_lang_pref: this.language,\n      cc_load_policy: showControls ? 1 : void 0,\n      color: this.color,\n      controls: showControls ? 1 : 0,\n      disablekb: !showControls || keyDisabled() ? 1 : 0,\n      enablejsapi: 1,\n      fs: 1,\n      hl: this.language,\n      iv_load_policy: showControls ? 1 : 3,\n      mute: muted() ? 1 : 0,\n      playsinline: playsinline() ? 1 : 0\n    };\n  }\n  _remote(command, arg) {\n    this._postMessage({\n      event: \"command\",\n      func: command,\n      args: arg ? [arg] : void 0\n    });\n  }\n  _onLoad() {\n    window.setTimeout(() => this._postMessage({ event: \"listening\" }), 100);\n  }\n  _onReady(trigger) {\n    this._ctx.delegate._ready(void 0, trigger);\n  }\n  _onPause(trigger) {\n    this._pausePromise?.resolve();\n    this._pausePromise = null;\n    this._notify(\"pause\", void 0, trigger);\n  }\n  _onTimeUpdate(time, trigger) {\n    const { duration, currentTime } = this._ctx.$state, boundTime = this._state === YouTubePlayerState._Ended ? duration() : time, detail = {\n      currentTime: boundTime,\n      played: this._played >= boundTime ? this._playedRange : this._playedRange = new TimeRange(0, this._played = time)\n    };\n    this._notify(\"time-update\", detail, trigger);\n    if (Math.abs(boundTime - currentTime()) > 1) {\n      this._notify(\"seeking\", boundTime, trigger);\n    }\n  }\n  _onProgress(buffered, seekable, trigger) {\n    const detail = {\n      buffered: new TimeRange(0, buffered),\n      seekable\n    };\n    this._notify(\"progress\", detail, trigger);\n    const { seeking, currentTime } = this._ctx.$state;\n    if (seeking() && buffered > currentTime()) {\n      this._onSeeked(trigger);\n    }\n  }\n  _onSeeked(trigger) {\n    const { paused, currentTime } = this._ctx.$state;\n    window.clearTimeout(this._seekingTimer);\n    this._seekingTimer = window.setTimeout(\n      () => {\n        this._notify(\"seeked\", currentTime(), trigger);\n        this._seekingTimer = -1;\n      },\n      paused() ? 100 : 0\n    );\n  }\n  _onEnded(trigger) {\n    const { seeking } = this._ctx.$state;\n    if (seeking())\n      this._onSeeked(trigger);\n    this._notify(\"end\", void 0, trigger);\n  }\n  _onStateChange(state, trigger) {\n    const { paused } = this._ctx.$state, isPlaying = state === YouTubePlayerState._Playing, isBuffering = state === YouTubePlayerState._Buffering;\n    if (isBuffering)\n      this._notify(\"waiting\", void 0, trigger);\n    if (paused() && (isBuffering || isPlaying)) {\n      this._playPromise?.resolve();\n      this._playPromise = null;\n      this._notify(\"play\", void 0, trigger);\n    }\n    switch (state) {\n      case YouTubePlayerState._Cued:\n        this._onReady(trigger);\n        break;\n      case YouTubePlayerState._Playing:\n        this._notify(\"playing\", void 0, trigger);\n        break;\n      case YouTubePlayerState._Paused:\n        this._onPause(trigger);\n        break;\n      case YouTubePlayerState._Ended:\n        this._onEnded(trigger);\n        break;\n    }\n    this._state = state;\n  }\n  _onMessage({ info }, event) {\n    if (!info)\n      return;\n    const { title, duration, playbackRate } = this._ctx.$state;\n    if (isObject(info.videoData) && info.videoData.title !== title()) {\n      this._notify(\"title-change\", info.videoData.title, event);\n    }\n    if (isNumber(info.duration) && info.duration !== duration()) {\n      if (isNumber(info.videoLoadedFraction)) {\n        const buffered = info.progressState?.loaded ?? info.videoLoadedFraction * info.duration, seekable = new TimeRange(0, info.duration);\n        this._onProgress(buffered, seekable, event);\n      }\n      this._notify(\"duration-change\", info.duration, event);\n    }\n    if (isNumber(info.playbackRate) && info.playbackRate !== playbackRate()) {\n      this._notify(\"rate-change\", info.playbackRate, event);\n    }\n    if (info.progressState) {\n      const {\n        current,\n        seekableStart,\n        seekableEnd,\n        loaded,\n        duration: _duration\n      } = info.progressState;\n      this._onTimeUpdate(current, event);\n      this._onProgress(loaded, new TimeRange(seekableStart, seekableEnd), event);\n      if (_duration !== duration()) {\n        this._notify(\"duration-change\", _duration, event);\n      }\n    }\n    if (isNumber(info.volume) && isBoolean(info.muted)) {\n      const detail = {\n        muted: info.muted,\n        volume: info.volume / 100\n      };\n      this._notify(\"volume-change\", detail, event);\n    }\n    if (isNumber(info.playerState) && info.playerState !== this._state) {\n      this._onStateChange(info.playerState, event);\n    }\n  }\n  _reset() {\n    this._state = -1;\n    this._seekingTimer = -1;\n    this._played = 0;\n    this._playedRange = new TimeRange(0, 0);\n    this._playPromise = null;\n    this._pausePromise = null;\n  }\n}\n\nexport { YouTubeProvider };\n"],"names":[],"sourceRoot":""}
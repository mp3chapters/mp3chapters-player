{"version":3,"file":"vendors-node_modules_vidstack_dist_dev_providers_vidstack-vimeo_js.bundle.js","mappings":";;;;;;;;;;;;;;AAAyE;;AAEzE;AACA;AACA;AACA;AACA;AACA,SAAS,wDAAW;AACpB;AACA;AACA;AACA;AACA,QAAQ,wDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAW;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEwB;;;;;;;;;;;;;;;;;;AC1B4G;AACpE;;AAEhE;AACA,kBAAkB,wDAAe;AACjC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,wDAAM;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY,iBAAiB,oBAAoB,eAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wDAAM;AACV,IAAI,wDAAW;AACf,IAAI,wDAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAI;AACvB,qCAAqC,wDAAiB;AACtD;AACA;AACA;AACA;AACA;AACA,wGAAwG,wDAAQ;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEiD;;;;;;;;;;;;;;;;;;;;;;ACpE2H;AAC5G;AACC;AACA;AACuB;AAC1B;AACyB;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,2DAAa;AACzC;AACA;AACA;AACA,iBAAiB,+DAAW;AAC5B;AACA,4BAA4B,2DAAS;AACrC,8BAA8B,2DAAS;AACvC;AACA;AACA;AACA,oBAAoB,+DAAM;AAC1B,gBAAgB,+DAAM;AACtB;AACA;AACA;AACA,wBAAwB,2DAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+DAAU;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAM;AACV,IAAI,+DAAM;AACV,IAAI,+DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,SAAS,+DAAI;AACb;AACA;AACA,0BAA0B,+DAAY;AACtC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,QAAQ,+DAAI;AACZ;AACA;AACA,2BAA2B,+DAAY;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAI;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS,+DAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB,SAAS,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAe;AACnC;AACA;AACA;AACA;AACA;AACA,+DAA+D,IAAI;AACnE;AACA;AACA;AACA,KAAK;AACL,gLAAgL,YAAY;AAC5L;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4DAA4D,UAAU;AACtE;AACA,eAAe,8DAAa;AAC5B,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA,cAAc,2DAAU;AACxB;AACA,aAAa,+DAAW;AACxB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe,eAAe,cAAc,sBAAsB,wBAAwB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAA4C;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,2DAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B,UAAU,eAAe,eAAe,WAAW;AAChG;AACA;AACA,gCAAgC,2DAAS;AACzC;AACA;AACA;AACA;AACA,sBAAsB,2DAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAO;AACnB;AACA;AACA;AACA;AACA,6BAA6B,+DAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAa;AACrC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAK,IAAI;AAC9B;AACA;AACA;AACA;AACA,0BAA0B,0DAAa;AACvC,0BAA0B,2DAAU;AACpC,MAAM;AACN,0BAA0B,2DAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+DAAI;AACjD;AACA;AACA,kCAAkC,2DAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4BAA4B,2DAAS;AACrC,8BAA8B,2DAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB","sources":["webpack://mp3chapters-player/./node_modules/vidstack/dist/dev/chunks/vidstack-IUoxhowK.js","webpack://mp3chapters-player/./node_modules/vidstack/dist/dev/chunks/vidstack-ZED4myhE.js","webpack://mp3chapters-player/./node_modules/vidstack/dist/dev/providers/vidstack-vimeo.js"],"sourcesContent":["import { i as isUndefined, a as isNumber } from './vidstack-KTx0QncX.js';\n\nclass RAFLoop {\n  constructor(_callback) {\n    this._callback = _callback;\n  }\n  _start() {\n    if (!isUndefined(this._id))\n      return;\n    this._loop();\n  }\n  _stop() {\n    if (isNumber(this._id))\n      window.cancelAnimationFrame(this._id);\n    this._id = void 0;\n  }\n  _loop() {\n    this._id = window.requestAnimationFrame(() => {\n      if (isUndefined(this._id))\n        return;\n      this._callback();\n      this._loop();\n    });\n  }\n}\n\nexport { RAFLoop as R };\n","import { v as deferredPromise, m as signal, e as effect, l as listenEvent, p as peek, r as isString } from './vidstack-KTx0QncX.js';\nimport { a as appendParamsToURL } from './vidstack-Yx-0ZQdX.js';\n\nfunction timedPromise(callback, ms = 3e3) {\n  const promise = deferredPromise();\n  setTimeout(() => {\n    const rejection = callback();\n    if (rejection)\n      promise.reject(rejection);\n  }, ms);\n  return promise;\n}\n\nclass EmbedProvider {\n  constructor(_iframe) {\n    this._iframe = _iframe;\n    this._src = signal(\"\");\n    /**\n     * Defines which referrer is sent when fetching the resource.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy}\n     */\n    this.referrerPolicy = null;\n    _iframe.setAttribute(\"frameBorder\", \"0\");\n    _iframe.setAttribute(\n      \"allow\",\n      \"autoplay; fullscreen; encrypted-media; picture-in-picture; accelerometer; gyroscope\"\n    );\n    if (this.referrerPolicy !== null) {\n      _iframe.setAttribute(\"referrerpolicy\", this.referrerPolicy);\n    }\n  }\n  get iframe() {\n    return this._iframe;\n  }\n  setup(ctx) {\n    effect(this._watchSrc.bind(this));\n    listenEvent(window, \"message\", this._onWindowMessage.bind(this));\n    listenEvent(this._iframe, \"load\", this._onLoad.bind(this));\n  }\n  _watchSrc() {\n    const src = this._src();\n    if (!src.length) {\n      this._iframe.setAttribute(\"src\", \"\");\n      return;\n    }\n    const params = peek(() => this._buildParams());\n    this._iframe.setAttribute(\"src\", appendParamsToURL(src, params));\n  }\n  _postMessage(message, target) {\n    this._iframe.contentWindow?.postMessage(JSON.stringify(message), target ?? \"*\");\n  }\n  _onWindowMessage(event) {\n    const origin = this._getOrigin(), isOriginMatch = event.source === this._iframe?.contentWindow && (!isString(origin) || origin === event.origin);\n    if (!isOriginMatch)\n      return;\n    try {\n      const message = JSON.parse(event.data);\n      if (message)\n        this._onMessage(message, event);\n      return;\n    } catch (e) {\n    }\n    if (event.data)\n      this._onMessage(event.data, event);\n  }\n}\n\nexport { EmbedProvider as E, timedPromise as t };\n","import { q as createScope, m as signal, e as effect, p as peek, r as isString, v as deferredPromise, l as listenEvent, w as isArray } from '../chunks/vidstack-KTx0QncX.js';\nimport { T as TimeRange } from '../chunks/vidstack-DTSGQ87h.js';\nimport { p as preconnect } from '../chunks/vidstack-Yx-0ZQdX.js';\nimport { L as ListSymbol } from '../chunks/vidstack-S5-ZnP-2.js';\nimport { c as coerceToError, Q as QualitySymbol } from '../chunks/vidstack-wDXs-Qf-.js';\nimport { R as RAFLoop } from '../chunks/vidstack-IUoxhowK.js';\nimport { E as EmbedProvider, t as timedPromise } from '../chunks/vidstack-ZED4myhE.js';\n\nconst trackedVimeoEvents = [\n  \"bufferend\",\n  \"bufferstart\",\n  // 'cuechange',\n  \"durationchange\",\n  \"ended\",\n  \"enterpictureinpicture\",\n  \"error\",\n  \"fullscreenchange\",\n  \"leavepictureinpicture\",\n  \"loaded\",\n  // 'loadeddata',\n  // 'loadedmetadata',\n  // 'loadstart',\n  \"playProgress\",\n  \"loadProgress\",\n  \"pause\",\n  \"play\",\n  \"playbackratechange\",\n  // 'progress',\n  \"qualitychange\",\n  \"seeked\",\n  \"seeking\",\n  // 'texttrackchange',\n  \"timeupdate\",\n  \"volumechange\",\n  \"waiting\"\n  // 'adstarted',\n  // 'adcompleted',\n  // 'aderror',\n  // 'adskipped',\n  // 'adallcompleted',\n  // 'adclicked',\n  // 'chapterchange',\n  // 'chromecastconnected',\n  // 'remoteplaybackavailabilitychange',\n  // 'remoteplaybackconnecting',\n  // 'remoteplaybackconnect',\n  // 'remoteplaybackdisconnect',\n  // 'liveeventended',\n  // 'liveeventstarted',\n  // 'livestreamoffline',\n  // 'livestreamonline',\n];\n\nclass VimeoProvider extends EmbedProvider {\n  constructor() {\n    super(...arguments);\n    this.$$PROVIDER_TYPE = \"VIMEO\";\n    this.scope = createScope();\n    this._played = 0;\n    this._playedRange = new TimeRange(0, 0);\n    this._seekableRange = new TimeRange(0, 0);\n    this._playPromise = null;\n    this._pausePromise = null;\n    this._videoInfoPromise = null;\n    this._videoId = signal(\"\");\n    this._pro = signal(false);\n    this._hash = null;\n    this._currentSrc = null;\n    this._currentCue = null;\n    this._timeRAF = new RAFLoop(this._onAnimationFrame.bind(this));\n    /**\n     * Whether tracking session data should be enabled on the embed, including cookies and analytics.\n     * This is turned off by default to be GDPR-compliant.\n     *\n     * @defaultValue `false`\n     */\n    this.cookies = false;\n    this.title = true;\n    this.byline = true;\n    this.portrait = true;\n    this.color = \"00ADEF\";\n  }\n  static {\n    this._videoIdRE = /(?:https:\\/\\/)?(?:player\\.)?vimeo(?:\\.com)?\\/(?:video\\/)?(\\d+)(?:\\?hash=(.*))?/;\n  }\n  static {\n    this._infoCache = /* @__PURE__ */ new Map();\n  }\n  get _notify() {\n    return this._ctx.delegate._notify;\n  }\n  get type() {\n    return \"vimeo\";\n  }\n  get currentSrc() {\n    return this._currentSrc;\n  }\n  get videoId() {\n    return this._videoId();\n  }\n  get hash() {\n    return this._hash;\n  }\n  get isPro() {\n    return this._pro();\n  }\n  preconnect() {\n    const connections = [\n      this._getOrigin(),\n      \"https://i.vimeocdn.com\",\n      \"https://f.vimeocdn.com\",\n      \"https://fresnel.vimeocdn.com\"\n    ];\n    for (const url of connections) {\n      preconnect(url, \"preconnect\");\n    }\n  }\n  setup(ctx) {\n    this._ctx = ctx;\n    super.setup(ctx);\n    effect(this._watchVideoId.bind(this));\n    effect(this._watchVideoInfo.bind(this));\n    effect(this._watchPro.bind(this));\n    this._notify(\"provider-setup\", this);\n  }\n  destroy() {\n    this._reset();\n    this._remote(\"destroy\");\n  }\n  async play() {\n    const { paused } = this._ctx.$state;\n    if (!peek(paused))\n      return;\n    if (!this._playPromise) {\n      this._playPromise = timedPromise(() => {\n        this._playPromise = null;\n        if (paused())\n          return \"Timed out.\";\n      });\n      this._remote(\"play\");\n    }\n    return this._playPromise.promise;\n  }\n  async pause() {\n    const { paused } = this._ctx.$state;\n    if (peek(paused))\n      return;\n    if (!this._pausePromise) {\n      this._pausePromise = timedPromise(() => {\n        this._pausePromise = null;\n        if (!paused())\n          return \"Timed out.\";\n      });\n      this._remote(\"pause\");\n    }\n    return this._pausePromise.promise;\n  }\n  setMuted(muted) {\n    this._remote(\"setMuted\", muted);\n  }\n  setCurrentTime(time) {\n    this._remote(\"seekTo\", time);\n  }\n  setVolume(volume) {\n    this._remote(\"setVolume\", volume);\n    this._remote(\"setMuted\", peek(this._ctx.$state.muted));\n  }\n  setPlaybackRate(rate) {\n    this._remote(\"setPlaybackRate\", rate);\n  }\n  async loadSource(src) {\n    if (!isString(src.src)) {\n      this._currentSrc = null;\n      this._hash = null;\n      this._videoId.set(\"\");\n      return;\n    }\n    const matches = src.src.match(VimeoProvider._videoIdRE), videoId = matches?.[1], hash = matches?.[2];\n    this._videoId.set(videoId ?? \"\");\n    this._hash = hash ?? null;\n    this._currentSrc = src;\n  }\n  _watchVideoId() {\n    this._reset();\n    const videoId = this._videoId();\n    if (!videoId) {\n      this._src.set(\"\");\n      return;\n    }\n    this._src.set(`${this._getOrigin()}/video/${videoId}`);\n  }\n  _watchVideoInfo() {\n    const src = this._src(), videoId = this._videoId(), cache = VimeoProvider._infoCache, info = cache.get(videoId);\n    if (!videoId)\n      return;\n    const promise = deferredPromise();\n    this._videoInfoPromise = promise;\n    if (info) {\n      promise.resolve(info);\n      return;\n    }\n    const oembedSrc = `https://vimeo.com/api/oembed.json?url=${src}`, abort = new AbortController();\n    window.fetch(oembedSrc, {\n      mode: \"cors\",\n      signal: abort.signal\n    }).then((response) => response.json()).then((data) => {\n      const thumnailRegex = /vimeocdn.com\\/video\\/(.*)?_/, thumbnailId = data?.thumbnail_url?.match(thumnailRegex)?.[1], poster = thumbnailId ? `https://i.vimeocdn.com/video/${thumbnailId}_1920x1080.webp` : \"\", info2 = {\n        title: data?.title ?? \"\",\n        duration: data?.duration ?? 0,\n        poster,\n        pro: data.account_type !== \"basic\"\n      };\n      cache.set(videoId, info2);\n      promise.resolve(info2);\n    }).catch((e) => {\n      promise.reject();\n      this._notify(\"error\", {\n        message: `Failed to fetch vimeo video info from \\`${oembedSrc}\\`.`,\n        code: 1,\n        error: coerceToError(e)\n      });\n    });\n    return () => {\n      promise.reject();\n      abort.abort();\n    };\n  }\n  _watchPro() {\n    const isPro = this._pro(), { $state, qualities } = this._ctx;\n    $state.canSetPlaybackRate.set(isPro);\n    qualities[ListSymbol._setReadonly](!isPro);\n    if (isPro) {\n      return listenEvent(qualities, \"change\", () => {\n        if (qualities.auto)\n          return;\n        const id = qualities.selected?.id;\n        if (id)\n          this._remote(\"setQuality\", id);\n      });\n    }\n  }\n  _getOrigin() {\n    return \"https://player.vimeo.com\";\n  }\n  _buildParams() {\n    const { $iosControls } = this._ctx, { keyDisabled } = this._ctx.$props, { controls, playsinline } = this._ctx.$state, showControls = controls() || $iosControls();\n    return {\n      title: this.title,\n      byline: this.byline,\n      color: this.color,\n      portrait: this.portrait,\n      controls: showControls,\n      h: this.hash,\n      keyboard: showControls && !keyDisabled(),\n      transparent: true,\n      playsinline: playsinline(),\n      dnt: !this.cookies\n    };\n  }\n  _onAnimationFrame() {\n    this._remote(\"getCurrentTime\");\n  }\n  _onTimeUpdate(time, trigger) {\n    const { currentTime, paused, seeking, bufferedEnd } = this._ctx.$state;\n    if (seeking() && paused()) {\n      this._remote(\"getBuffered\");\n      if (bufferedEnd() > time)\n        this._notify(\"seeked\", time, trigger);\n    }\n    if (currentTime() === time)\n      return;\n    const prevTime = currentTime(), detail = {\n      currentTime: time,\n      played: this._played >= time ? this._playedRange : this._playedRange = new TimeRange(0, this._played = time)\n    };\n    this._notify(\"time-update\", detail, trigger);\n    if (Math.abs(prevTime - time) > 1.5) {\n      this._notify(\"seeking\", time, trigger);\n      if (!paused() && bufferedEnd() < time) {\n        this._notify(\"waiting\", void 0, trigger);\n      }\n    }\n  }\n  _onSeeked(time, trigger) {\n    this._notify(\"seeked\", time, trigger);\n  }\n  _onReady(trigger) {\n    const videoId = this._videoId();\n    this._videoInfoPromise?.promise.then((info) => {\n      if (!info)\n        return;\n      const { title, poster, duration, pro } = info, { $iosControls } = this._ctx, { controls } = this._ctx.$state, showControls = controls() || $iosControls();\n      this._timeRAF._start();\n      this._pro.set(pro);\n      this._seekableRange = new TimeRange(0, duration);\n      this._notify(\"poster-change\", poster, trigger);\n      this._notify(\"title-change\", title, trigger);\n      this._notify(\"duration-change\", duration, trigger);\n      const detail = {\n        buffered: new TimeRange(0, 0),\n        seekable: this._seekableRange,\n        duration\n      };\n      this._ctx.delegate._ready(detail, trigger);\n      if (!showControls) {\n        this._remote(\"_hideOverlay\");\n      }\n      this._remote(\"getQualities\");\n    }).catch((e) => {\n      if (videoId !== this._videoId())\n        return;\n      this._notify(\"error\", {\n        message: `Failed to fetch oembed data`,\n        code: 2,\n        error: coerceToError(e)\n      });\n    });\n  }\n  _onMethod(method, data, trigger) {\n    switch (method) {\n      case \"getCurrentTime\":\n        this._onTimeUpdate(data, trigger);\n        break;\n      case \"getBuffered\":\n        if (isArray(data) && data.length) {\n          this._onLoadProgress(data[data.length - 1][1], trigger);\n        }\n        break;\n      case \"setMuted\":\n        this._onVolumeChange(peek(this._ctx.$state.volume), data, trigger);\n        break;\n      case \"getChapters\":\n        break;\n      case \"getQualities\":\n        this._onQualitiesChange(data, trigger);\n        break;\n    }\n  }\n  _attachListeners() {\n    for (const type of trackedVimeoEvents) {\n      this._remote(\"addEventListener\", type);\n    }\n  }\n  _onPause(trigger) {\n    this._notify(\"pause\", void 0, trigger);\n    this._pausePromise?.resolve();\n    this._pausePromise = null;\n  }\n  _onPlay(trigger) {\n    this._notify(\"play\", void 0, trigger);\n    this._playPromise?.resolve();\n    this._playPromise = null;\n  }\n  _onPlayProgress(trigger) {\n    const { paused } = this._ctx.$state;\n    if (!paused()) {\n      this._notify(\"playing\", void 0, trigger);\n    }\n  }\n  _onLoadProgress(buffered, trigger) {\n    const detail = {\n      buffered: new TimeRange(0, buffered),\n      seekable: this._seekableRange\n    };\n    this._notify(\"progress\", detail, trigger);\n  }\n  _onBufferStart(trigger) {\n    this._notify(\"waiting\", void 0, trigger);\n  }\n  _onBufferEnd(trigger) {\n    const { paused } = this._ctx.$state;\n    if (!paused())\n      this._notify(\"playing\", void 0, trigger);\n  }\n  _onWaiting(trigger) {\n    const { paused } = this._ctx.$state;\n    if (paused()) {\n      this._notify(\"play\", void 0, trigger);\n    }\n    this._notify(\"waiting\", void 0, trigger);\n  }\n  _onVolumeChange(volume, muted, trigger) {\n    const detail = { volume, muted };\n    this._notify(\"volume-change\", detail, trigger);\n  }\n  // protected _onTextTrackChange(track: VimeoTextTrack, trigger: Event) {\n  //   const textTrack = this._ctx.textTracks.toArray().find((t) => t.language === track.language);\n  //   if (textTrack) textTrack.mode = track.mode;\n  // }\n  // protected _onTextTracksChange(tracks: VimeoTextTrack[], trigger: Event) {\n  //   for (const init of tracks) {\n  //     const textTrack = new TextTrack({\n  //       ...init,\n  //       label: init.label.replace('auto-generated', 'auto'),\n  //     });\n  //     textTrack[TextTrackSymbol._readyState] = 2;\n  //     this._ctx.textTracks.add(textTrack, trigger);\n  //     textTrack.setMode(init.mode, trigger);\n  //   }\n  // }\n  // protected _onCueChange(cue: VimeoTextCue, trigger: Event) {\n  //   const { textTracks, $state } = this._ctx,\n  //     { currentTime } = $state,\n  //     track = textTracks.selected;\n  //   if (this._currentCue) track?.removeCue(this._currentCue, trigger);\n  //   this._currentCue = new window.VTTCue(currentTime(), Number.MAX_SAFE_INTEGER, cue.text);\n  //   track?.addCue(this._currentCue, trigger);\n  // }\n  _onQualitiesChange(qualities, trigger) {\n    this._ctx.qualities[QualitySymbol._enableAuto] = qualities.some((q) => q.id === \"auto\") ? () => {\n      this._remote(\"setQuality\", \"auto\");\n    } : void 0;\n    for (const quality of qualities) {\n      if (quality.id === \"auto\")\n        continue;\n      const height = +quality.id.slice(0, -1);\n      if (isNaN(height))\n        continue;\n      this._ctx.qualities[ListSymbol._add](\n        {\n          id: quality.id,\n          width: height * (16 / 9),\n          height,\n          codec: \"avc1,h.264\",\n          bitrate: -1\n        },\n        trigger\n      );\n    }\n    this._onQualityChange(\n      qualities.find((q) => q.active),\n      trigger\n    );\n  }\n  _onQualityChange({ id } = {}, trigger) {\n    if (!id)\n      return;\n    const isAuto = id === \"auto\", newQuality = this._ctx.qualities.toArray().find((q) => q.id === id);\n    if (isAuto) {\n      this._ctx.qualities[QualitySymbol._setAuto](isAuto, trigger);\n      this._ctx.qualities[ListSymbol._select](void 0, true, trigger);\n    } else {\n      this._ctx.qualities[ListSymbol._select](newQuality, true, trigger);\n    }\n  }\n  _onEvent(event, payload, trigger) {\n    switch (event) {\n      case \"ready\":\n        this._attachListeners();\n        break;\n      case \"loaded\":\n        this._onReady(trigger);\n        break;\n      case \"play\":\n        this._onPlay(trigger);\n        break;\n      case \"playProgress\":\n        this._onPlayProgress(trigger);\n        break;\n      case \"pause\":\n        this._onPause(trigger);\n        break;\n      case \"loadProgress\":\n        this._onLoadProgress(payload.seconds, trigger);\n        break;\n      case \"waiting\":\n        this._onWaiting(trigger);\n        break;\n      case \"bufferstart\":\n        this._onBufferStart(trigger);\n        break;\n      case \"bufferend\":\n        this._onBufferEnd(trigger);\n        break;\n      case \"volumechange\":\n        this._onVolumeChange(payload.volume, peek(this._ctx.$state.muted), trigger);\n        break;\n      case \"durationchange\":\n        this._seekableRange = new TimeRange(0, payload.duration);\n        this._notify(\"duration-change\", payload.duration, trigger);\n        break;\n      case \"playbackratechange\":\n        this._notify(\"rate-change\", payload.playbackRate, trigger);\n        break;\n      case \"qualitychange\":\n        this._onQualityChange(payload, trigger);\n        break;\n      case \"fullscreenchange\":\n        this._notify(\"fullscreen-change\", payload.fullscreen, trigger);\n        break;\n      case \"enterpictureinpicture\":\n        this._notify(\"picture-in-picture-change\", true, trigger);\n        break;\n      case \"leavepictureinpicture\":\n        this._notify(\"picture-in-picture-change\", false, trigger);\n        break;\n      case \"ended\":\n        this._notify(\"end\", void 0, trigger);\n        break;\n      case \"error\":\n        this._onError(payload, trigger);\n        break;\n      case \"seeked\":\n        this._onSeeked(payload.seconds, trigger);\n        break;\n    }\n  }\n  _onError(error, trigger) {\n    if (error.method === \"play\") {\n      this._playPromise?.reject(error.message);\n      return;\n    }\n    {\n      this._ctx.logger?.errorGroup(`[vimeo]: ${error.message}`).labelledLog(\"Error\", error).labelledLog(\"Provider\", this).labelledLog(\"Event\", trigger).dispatch();\n    }\n  }\n  _onMessage(message, event) {\n    if (message.event) {\n      this._onEvent(message.event, message.data, event);\n    } else if (message.method) {\n      this._onMethod(message.method, message.value, event);\n    }\n  }\n  _onLoad() {\n  }\n  _remote(command, arg) {\n    return this._postMessage({\n      method: command,\n      value: arg\n    });\n  }\n  _reset() {\n    this._timeRAF._stop();\n    this._played = 0;\n    this._playedRange = new TimeRange(0, 0);\n    this._seekableRange = new TimeRange(0, 0);\n    this._playPromise = null;\n    this._pausePromise = null;\n    this._videoInfoPromise = null;\n    this._currentCue = null;\n    this._pro.set(false);\n  }\n}\n\nexport { VimeoProvider };\n"],"names":[],"sourceRoot":""}
{"version":3,"file":"vendors-node_modules_vidstack_dist_dev_providers_vidstack-hls_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;AAAwH;AAClB;AAClD;AAC8H;AAC1F;AAC1B;AAClC;AACY;;AAExC,iCAAiC,+DAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAI,6DAA6D,+DAAI;AACxF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAQ,mBAAmB,wBAAwB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAa;AAC/B,IAAI,+DAAW;AACf,IAAI,+DAAW;AACf,yBAAyB,+DAAM;AAC/B;AACA;AACA;AACA;AACA,oBAAoB,2DAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAQ,8BAA8B,QAAQ;AACjF;AACA;AACA,sBAAsB,2DAAQ,cAAc,cAAc;AAC1D;AACA,oBAAoB,wBAAwB;AAC5C,+HAA+H,2DAAS;AACxI,mBAAmB,oBAAoB,EAAE,EAAE;AAC3C;AACA;AACA;AACA;AACA,OAAO;AACP,YAAY,2DAAe;AAC3B,YAAY,2DAAe;AAC3B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA,sBAAsB,2DAAQ,cAAc,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAU;AACtC;AACA;AACA,YAAY,2DAAQ,cAAc,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAU;AACpC;AACA;AACA,YAAY,2DAAQ,cAAc,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAsD;AAClE,sBAAsB,2DAAQ,cAAc,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAa;AACvC;AACA;AACA,4BAA4B,2DAAU;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,2DAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,2DAAQ,cAAc,gBAAgB;AAClE;AACA;AACA;AACA,kDAAkD,UAAU,uLAAuL,+DAAI,wDAAwD,qBAAqB;AACpU;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA,QAAQ,2DAAS;AACjB;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS,+DAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAa;AACvC;AACA;AACA;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAW,WAAW,+DAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2DAAQ;AAC5C,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAQ;AAClB;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,kBAAkB,8DAAa;AAC/B;AACA;AACA;AACA;AACA,UAAU,2DAAQ;AAClB;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+CAA+C;AAC/C,MAAM,+DAAW;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,QAAQ,KAAI,0FAA0F,CAAE;AACxG;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,gDAAgD;AAChD,OAAO,+DAAQ;AACf;AACA;AACA;AACA,UAAU,+DAAU;AACpB,SAAS,+DAAU;AACnB;AACA,QAAQ,KAAI,8FAA8F,CAAE;AAC5G;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,6DAAa;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc,6BAA6B,OAAO;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,+DAAQ;AACjB;AACA,IAAI,+DAAU;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAI;AACtB;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS,+DAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;ACrbuF;AACsB;AAC7E;AAC+B;AAC9C;AACA;;AAExC;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAS;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAS;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,UAAU,2DAAe,cAAc;AACvC,UAAU,2DAAe;AACzB,UAAU,2DAAe;AACzB;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAW;AACf,IAAI,+DAAW;AACf;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAW;AACf;AACA;AACA,WAAW,+DAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAQ;AAClB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,gEAAiB;AAC7C;AACA;AACA;AACA,IAAI,+DAAM;AACV,UAAU,+DAAuB;AACjC;AACA;AACA;AACA,QAAQ,SAAS,+DAAsB;AACvC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAkB;AAC1B;AACA;AACA;AACA,IAAI,+DAAS;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEyB","sources":["webpack://mp3chapters-player/./node_modules/vidstack/dist/dev/providers/vidstack-hls.js","webpack://mp3chapters-player/./node_modules/vidstack/dist/dev/providers/vidstack-video.js"],"sourcesContent":["import { b as TextTrack, T as TextTrackSymbol, l as loadScript, p as preconnect } from '../chunks/vidstack-Yx-0ZQdX.js';\nimport { L as ListSymbol, I as IS_CHROME, i as isHLSSupported } from '../chunks/vidstack-S5-ZnP-2.js';\nimport { VideoProvider } from './vidstack-video.js';\nimport { p as peek, D as DOMEvent, l as listenEvent, e as effect, r as isString, K as camelToKebabCase, i as isUndefined, x as isFunction } from '../chunks/vidstack-KTx0QncX.js';\nimport { Q as QualitySymbol, c as coerceToError } from '../chunks/vidstack-wDXs-Qf-.js';\nimport { R as RAFLoop } from '../chunks/vidstack-IUoxhowK.js';\nimport './vidstack-html.js';\nimport '../chunks/vidstack-ZF6S2MdD.js';\n\nconst toDOMEventType = (type) => camelToKebabCase(type);\nclass HLSController {\n  constructor(_video) {\n    this._video = _video;\n    this._instance = null;\n    this._stopLiveSync = null;\n    this._config = {};\n    this._callbacks = /* @__PURE__ */ new Set();\n    this._retryLoadingTimer = -1;\n  }\n  get instance() {\n    return this._instance;\n  }\n  setup(ctor, ctx) {\n    this._ctx = ctx;\n    const isLive = peek(ctx.$state.streamType).includes(\"live\"), isLiveLowLatency = peek(ctx.$state.streamType).includes(\"ll-\");\n    this._instance = new ctor({\n      lowLatencyMode: isLiveLowLatency,\n      backBufferLength: isLiveLowLatency ? 4 : isLive ? 8 : void 0,\n      renderTextTracksNatively: false,\n      ...this._config\n    });\n    const dispatcher = this._dispatchHLSEvent.bind(this);\n    for (const event of Object.values(ctor.Events))\n      this._instance.on(event, dispatcher);\n    this._instance.on(ctor.Events.ERROR, this._onError.bind(this));\n    for (const callback of this._callbacks)\n      callback(this._instance);\n    ctx.player.dispatch(new DOMEvent(\"hls-instance\", { detail: this._instance }));\n    this._instance.attachMedia(this._video);\n    this._instance.on(ctor.Events.FRAG_LOADING, this._onFragLoading.bind(this));\n    this._instance.on(ctor.Events.AUDIO_TRACK_SWITCHED, this._onAudioSwitch.bind(this));\n    this._instance.on(ctor.Events.LEVEL_SWITCHED, this._onLevelSwitched.bind(this));\n    this._instance.on(ctor.Events.LEVEL_LOADED, this._onLevelLoaded.bind(this));\n    this._instance.on(ctor.Events.NON_NATIVE_TEXT_TRACKS_FOUND, this._onTracksFound.bind(this));\n    this._instance.on(ctor.Events.CUES_PARSED, this._onCuesParsed.bind(this));\n    ctx.qualities[QualitySymbol._enableAuto] = this._enableAutoQuality.bind(this);\n    listenEvent(ctx.qualities, \"change\", this._onQualityChange.bind(this));\n    listenEvent(ctx.audioTracks, \"change\", this._onAudioChange.bind(this));\n    this._stopLiveSync = effect(this._liveSync.bind(this));\n  }\n  _liveSync() {\n    if (!this._ctx.$state.live())\n      return;\n    const raf = new RAFLoop(this._liveSyncPosition.bind(this));\n    raf._start();\n    return raf._stop.bind(raf);\n  }\n  _liveSyncPosition() {\n    this._ctx.$state.liveSyncPosition.set(this._instance?.liveSyncPosition ?? Infinity);\n  }\n  _dispatchHLSEvent(eventType, detail) {\n    this._ctx.player?.dispatch(new DOMEvent(toDOMEventType(eventType), { detail }));\n  }\n  _onTracksFound(eventType, data) {\n    const event = new DOMEvent(eventType, { detail: data });\n    let currentTrack = -1;\n    for (let i = 0; i < data.tracks.length; i++) {\n      const nonNativeTrack = data.tracks[i], init = nonNativeTrack.subtitleTrack ?? nonNativeTrack.closedCaptions, track = new TextTrack({\n        id: `hls-${nonNativeTrack.kind}${i}`,\n        src: init?.url,\n        label: nonNativeTrack.label,\n        language: init?.lang,\n        kind: nonNativeTrack.kind\n      });\n      track[TextTrackSymbol._readyState] = 2;\n      track[TextTrackSymbol._onModeChange] = () => {\n        if (track.mode === \"showing\") {\n          this._instance.subtitleTrack = i;\n          currentTrack = i;\n        } else if (currentTrack === i) {\n          this._instance.subtitleTrack = -1;\n          currentTrack = -1;\n        }\n      };\n      if (nonNativeTrack.default)\n        track.setMode(\"showing\", event);\n      this._ctx.textTracks.add(track, event);\n    }\n  }\n  _onCuesParsed(eventType, data) {\n    const track = this._ctx.textTracks.getById(`hls-${data.track}`);\n    if (!track)\n      return;\n    const event = new DOMEvent(eventType, { detail: data });\n    for (const cue of data.cues) {\n      cue.positionAlign = \"auto\";\n      track.addCue(cue, event);\n    }\n  }\n  _onAudioSwitch(eventType, data) {\n    const track = this._ctx.audioTracks[data.id];\n    if (track) {\n      this._ctx.audioTracks[ListSymbol._select](\n        track,\n        true,\n        new DOMEvent(eventType, { detail: data })\n      );\n    }\n  }\n  _onLevelSwitched(eventType, data) {\n    const quality = this._ctx.qualities[data.level];\n    if (quality) {\n      this._ctx.qualities[ListSymbol._select](\n        quality,\n        true,\n        new DOMEvent(eventType, { detail: data })\n      );\n    }\n  }\n  _onLevelLoaded(eventType, data) {\n    if (this._ctx.$state.canPlay())\n      return;\n    const { type, live, totalduration: duration, targetduration } = data.details;\n    const event = new DOMEvent(eventType, { detail: data });\n    this._ctx.delegate._notify(\n      \"stream-type-change\",\n      live ? type === \"EVENT\" && Number.isFinite(duration) && targetduration >= 10 ? \"live:dvr\" : \"live\" : \"on-demand\",\n      event\n    );\n    this._ctx.delegate._notify(\"duration-change\", duration, event);\n    const media = this._instance.media;\n    if (this._instance.currentLevel === -1) {\n      this._ctx.qualities[QualitySymbol._setAuto](true, event);\n    }\n    for (const track of this._instance.audioTracks) {\n      this._ctx.audioTracks[ListSymbol._add](\n        {\n          id: track.id + \"\",\n          label: track.name,\n          language: track.lang || \"\",\n          kind: \"main\"\n        },\n        event\n      );\n    }\n    for (const level of this._instance.levels) {\n      this._ctx.qualities[ListSymbol._add](\n        {\n          id: (level.id ?? level.height + \"p\") + \"\",\n          width: level.width,\n          height: level.height,\n          codec: level.codecSet,\n          bitrate: level.bitrate\n        },\n        event\n      );\n    }\n    media.dispatchEvent(new DOMEvent(\"canplay\", { trigger: event }));\n  }\n  _onError(eventType, data) {\n    {\n      this._ctx.logger?.errorGroup(`HLS error \\`${eventType}\\``).labelledLog(\"Media Element\", this._instance?.media).labelledLog(\"HLS Instance\", this._instance).labelledLog(\"Event Type\", eventType).labelledLog(\"Data\", data).labelledLog(\"Src\", peek(this._ctx.$state.source)).labelledLog(\"Media Store\", { ...this._ctx.$state }).dispatch();\n    }\n    if (data.fatal) {\n      switch (data.type) {\n        case \"networkError\":\n          this._onNetworkError(data.error);\n          break;\n        case \"mediaError\":\n          this._instance?.recoverMediaError();\n          break;\n        default:\n          this._onFatalError(data.error);\n          break;\n      }\n    }\n  }\n  _onFragLoading() {\n    if (this._retryLoadingTimer >= 0)\n      this._clearRetryTimer();\n  }\n  _onNetworkError(error) {\n    this._clearRetryTimer();\n    this._instance?.startLoad();\n    this._retryLoadingTimer = window.setTimeout(() => {\n      this._retryLoadingTimer = -1;\n      this._onFatalError(error);\n    }, 5e3);\n  }\n  _clearRetryTimer() {\n    clearTimeout(this._retryLoadingTimer);\n    this._retryLoadingTimer = -1;\n  }\n  _onFatalError(error) {\n    this._instance?.destroy();\n    this._instance = null;\n    this._ctx.delegate._notify(\"error\", {\n      message: error.message,\n      code: 1,\n      error\n    });\n  }\n  _enableAutoQuality() {\n    if (this._instance)\n      this._instance.currentLevel = -1;\n  }\n  _onQualityChange() {\n    const { qualities } = this._ctx;\n    if (!this._instance || qualities.auto)\n      return;\n    this._instance[qualities.switch + \"Level\"] = qualities.selectedIndex;\n    if (IS_CHROME)\n      this._video.currentTime = this._video.currentTime;\n  }\n  _onAudioChange() {\n    const { audioTracks } = this._ctx;\n    if (this._instance && this._instance.audioTrack !== audioTracks.selectedIndex) {\n      this._instance.audioTrack = audioTracks.selectedIndex;\n    }\n  }\n  _loadSource(src) {\n    if (!isString(src.src))\n      return;\n    this._clearRetryTimer();\n    this._instance?.loadSource(src.src);\n  }\n  _destroy() {\n    this._clearRetryTimer();\n    if (this._ctx)\n      this._ctx.qualities[QualitySymbol._enableAuto] = void 0;\n    this._instance?.destroy();\n    this._instance = null;\n    this._stopLiveSync?.();\n    this._stopLiveSync = null;\n    this._ctx?.logger?.info(\"\\u{1F3D7}\\uFE0F Destroyed HLS instance\");\n  }\n}\n\nclass HLSLibLoader {\n  constructor(_lib, _ctx, _callback) {\n    this._lib = _lib;\n    this._ctx = _ctx;\n    this._callback = _callback;\n    this._startLoading();\n  }\n  async _startLoading() {\n    this._ctx.logger?.info(\"\\u{1F3D7}\\uFE0F Loading HLS Library\");\n    const callbacks = {\n      onLoadStart: this._onLoadStart.bind(this),\n      onLoaded: this._onLoaded.bind(this),\n      onLoadError: this._onLoadError.bind(this)\n    };\n    let ctor = await loadHLSScript(this._lib, callbacks);\n    if (isUndefined(ctor) && !isString(this._lib))\n      ctor = await importHLS(this._lib, callbacks);\n    if (!ctor)\n      return null;\n    if (!ctor.isSupported()) {\n      const message = \"[vidstack]: `hls.js` is not supported in this environment\";\n      this._ctx.logger?.error(message);\n      this._ctx.player.dispatch(new DOMEvent(\"hls-unsupported\"));\n      this._ctx.delegate._notify(\"error\", { message, code: 4 });\n      return null;\n    }\n    return ctor;\n  }\n  _onLoadStart() {\n    {\n      this._ctx.logger?.infoGroup(\"Starting to load `hls.js`\").labelledLog(\"URL\", this._lib).dispatch();\n    }\n    this._ctx.player.dispatch(new DOMEvent(\"hls-lib-load-start\"));\n  }\n  _onLoaded(ctor) {\n    {\n      this._ctx.logger?.infoGroup(\"Loaded `hls.js`\").labelledLog(\"Library\", this._lib).labelledLog(\"Constructor\", ctor).dispatch();\n    }\n    this._ctx.player.dispatch(\n      new DOMEvent(\"hls-lib-loaded\", {\n        detail: ctor\n      })\n    );\n    this._callback(ctor);\n  }\n  _onLoadError(e) {\n    const error = coerceToError(e);\n    {\n      this._ctx.logger?.errorGroup(\"Failed to load `hls.js`\").labelledLog(\"Library\", this._lib).labelledLog(\"Error\", e).dispatch();\n    }\n    this._ctx.player.dispatch(\n      new DOMEvent(\"hls-lib-load-error\", {\n        detail: error\n      })\n    );\n    this._ctx.delegate._notify(\"error\", {\n      message: error.message,\n      code: 4,\n      error\n    });\n  }\n}\nasync function importHLS(loader, callbacks = {}) {\n  if (isUndefined(loader))\n    return void 0;\n  callbacks.onLoadStart?.();\n  if (loader.prototype && loader.prototype !== Function) {\n    callbacks.onLoaded?.(loader);\n    return loader;\n  }\n  try {\n    const ctor = (await loader())?.default;\n    if (ctor && !!ctor.isSupported) {\n      callbacks.onLoaded?.(ctor);\n    } else {\n      throw Error(\n        true ? \"[vidstack] failed importing `hls.js`. Dynamic import returned invalid constructor.\" : \"\"\n      );\n    }\n    return ctor;\n  } catch (err) {\n    callbacks.onLoadError?.(err);\n  }\n  return void 0;\n}\nasync function loadHLSScript(src, callbacks = {}) {\n  if (!isString(src))\n    return void 0;\n  callbacks.onLoadStart?.();\n  try {\n    await loadScript(src);\n    if (!isFunction(window.Hls)) {\n      throw Error(\n        true ? \"[vidstack] failed loading `hls.js`. Could not find a valid `Hls` constructor on window\" : \"\"\n      );\n    }\n    const ctor = window.Hls;\n    callbacks.onLoaded?.(ctor);\n    return ctor;\n  } catch (err) {\n    callbacks.onLoadError?.(err);\n  }\n  return void 0;\n}\n\nconst JS_DELIVR_CDN = \"https://cdn.jsdelivr.net\";\nclass HLSProvider extends VideoProvider {\n  constructor() {\n    super(...arguments);\n    this.$$PROVIDER_TYPE = \"HLS\";\n    this._ctor = null;\n    this._controller = new HLSController(this.video);\n    this._library = `${JS_DELIVR_CDN}/npm/hls.js@^1.0.0/dist/hls${\".js\" }`;\n  }\n  /**\n   * The `hls.js` constructor.\n   */\n  get ctor() {\n    return this._ctor;\n  }\n  /**\n   * The current `hls.js` instance.\n   */\n  get instance() {\n    return this._controller.instance;\n  }\n  static {\n    /**\n     * Whether `hls.js` is supported in this environment.\n     */\n    this.supported = isHLSSupported();\n  }\n  get type() {\n    return \"hls\";\n  }\n  get canLiveSync() {\n    return true;\n  }\n  /**\n   * The `hls.js` configuration object.\n   *\n   * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#fine-tuning}\n   */\n  get config() {\n    return this._controller._config;\n  }\n  set config(config) {\n    this._controller._config = config;\n  }\n  /**\n   * The `hls.js` constructor (supports dynamic imports) or a URL of where it can be found.\n   *\n   * @defaultValue `https://cdn.jsdelivr.net/npm/hls.js@^1.0.0/dist/hls.min.js`\n   */\n  get library() {\n    return this._library;\n  }\n  set library(library) {\n    this._library = library;\n  }\n  preconnect() {\n    if (!isString(this._library))\n      return;\n    preconnect(this._library);\n  }\n  setup(ctx) {\n    super.setup(ctx);\n    new HLSLibLoader(this._library, ctx, (ctor) => {\n      this._ctor = ctor;\n      this._controller.setup(ctor, ctx);\n      ctx.delegate._notify(\"provider-setup\", this);\n      const src = peek(ctx.$state.source);\n      if (src)\n        this.loadSource(src);\n    });\n  }\n  async loadSource(src, preload) {\n    if (!isString(src.src))\n      return;\n    this._media.preload = preload || \"\";\n    this._controller._loadSource(src);\n    this._currentSrc = src;\n  }\n  /**\n   * The given callback is invoked when a new `hls.js` instance is created and right before it's\n   * attached to media.\n   */\n  onInstance(callback) {\n    const instance = this._controller.instance;\n    if (instance)\n      callback(instance);\n    this._controller._callbacks.add(callback);\n    return () => this._controller._callbacks.delete(callback);\n  }\n  destroy() {\n    this._controller._destroy();\n  }\n}\n\nexport { HLSProvider };\n","import { o as onDispose, l as listenEvent, D as DOMEvent, s as scoped } from '../chunks/vidstack-KTx0QncX.js';\nimport { d as canUsePictureInPicture, e as canUseVideoPresentation, b as canPlayHLSNatively } from '../chunks/vidstack-S5-ZnP-2.js';\nimport { HTMLMediaProvider } from './vidstack-html.js';\nimport { b as TextTrack, T as TextTrackSymbol } from '../chunks/vidstack-Yx-0ZQdX.js';\nimport '../chunks/vidstack-ZF6S2MdD.js';\nimport '../chunks/vidstack-IUoxhowK.js';\n\nclass NativeHLSTextTracks {\n  constructor(_video, _ctx) {\n    this._video = _video;\n    this._ctx = _ctx;\n    _video.textTracks.onaddtrack = this._onAddTrack.bind(this);\n    onDispose(this._onDispose.bind(this));\n  }\n  _onAddTrack(event) {\n    const nativeTrack = event.track;\n    if (!nativeTrack || findTextTrackElement(this._video, nativeTrack))\n      return;\n    const track = new TextTrack({\n      id: nativeTrack.id,\n      kind: nativeTrack.kind,\n      label: nativeTrack.label,\n      language: nativeTrack.language,\n      type: \"vtt\"\n    });\n    track[TextTrackSymbol._native] = { track: nativeTrack };\n    track[TextTrackSymbol._readyState] = 2;\n    track[TextTrackSymbol._nativeHLS] = true;\n    let lastIndex = 0;\n    const onCueChange = (event2) => {\n      if (!nativeTrack.cues)\n        return;\n      for (let i = lastIndex; i < nativeTrack.cues.length; i++) {\n        track.addCue(nativeTrack.cues[i], event2);\n        lastIndex++;\n      }\n    };\n    onCueChange(event);\n    nativeTrack.oncuechange = onCueChange;\n    this._ctx.textTracks.add(track, event);\n    track.setMode(nativeTrack.mode, event);\n  }\n  _onDispose() {\n    this._video.textTracks.onaddtrack = null;\n    for (const track of this._ctx.textTracks) {\n      const nativeTrack = track[TextTrackSymbol._native]?.track;\n      if (nativeTrack?.oncuechange)\n        nativeTrack.oncuechange = null;\n    }\n  }\n}\nfunction findTextTrackElement(video, track) {\n  return Array.from(video.children).find((el) => el.track === track);\n}\n\nclass VideoPictureInPicture {\n  constructor(_video, _media) {\n    this._video = _video;\n    this._media = _media;\n    this._onChange = (active, event) => {\n      this._media.delegate._notify(\"picture-in-picture-change\", active, event);\n    };\n    listenEvent(this._video, \"enterpictureinpicture\", this._onEnter.bind(this));\n    listenEvent(this._video, \"leavepictureinpicture\", this._onExit.bind(this));\n  }\n  get active() {\n    return document.pictureInPictureElement === this._video;\n  }\n  get supported() {\n    return canUsePictureInPicture(this._video);\n  }\n  async enter() {\n    return this._video.requestPictureInPicture();\n  }\n  exit() {\n    return document.exitPictureInPicture();\n  }\n  _onEnter(event) {\n    this._onChange(true, event);\n  }\n  _onExit(event) {\n    this._onChange(false, event);\n  }\n}\n\nclass VideoPresentation {\n  constructor(_video, _media) {\n    this._video = _video;\n    this._media = _media;\n    this._mode = \"inline\";\n    listenEvent(this._video, \"webkitpresentationmodechanged\", this._onModeChange.bind(this));\n  }\n  get _supported() {\n    return canUseVideoPresentation(this._video);\n  }\n  async _setPresentationMode(mode) {\n    if (this._mode === mode)\n      return;\n    this._video.webkitSetPresentationMode(mode);\n  }\n  _onModeChange(event) {\n    const prevMode = this._mode;\n    this._mode = this._video.webkitPresentationMode;\n    {\n      this._media.logger?.infoGroup(\"presentation mode change\").labelledLog(\"Mode\", this._mode).labelledLog(\"Event\", event).dispatch();\n    }\n    this._media.player?.dispatch(\n      new DOMEvent(\"video-presentation-change\", {\n        detail: this._mode,\n        trigger: event\n      })\n    );\n    [\"fullscreen\", \"picture-in-picture\"].forEach((type) => {\n      if (this._mode === type || prevMode === type) {\n        this._media.delegate._notify(`${type}-change`, this._mode === type, event);\n      }\n    });\n  }\n}\nclass FullscreenPresentationAdapter {\n  constructor(_presentation) {\n    this._presentation = _presentation;\n  }\n  get active() {\n    return this._presentation._mode === \"fullscreen\";\n  }\n  get supported() {\n    return this._presentation._supported;\n  }\n  async enter() {\n    this._presentation._setPresentationMode(\"fullscreen\");\n  }\n  async exit() {\n    this._presentation._setPresentationMode(\"inline\");\n  }\n}\nclass PIPPresentationAdapter {\n  constructor(_presentation) {\n    this._presentation = _presentation;\n  }\n  get active() {\n    return this._presentation._mode === \"picture-in-picture\";\n  }\n  get supported() {\n    return this._presentation._supported;\n  }\n  async enter() {\n    this._presentation._setPresentationMode(\"picture-in-picture\");\n  }\n  async exit() {\n    this._presentation._setPresentationMode(\"inline\");\n  }\n}\n\nclass VideoProvider extends HTMLMediaProvider {\n  constructor(video, ctx) {\n    super(video);\n    this.$$PROVIDER_TYPE = \"VIDEO\";\n    scoped(() => {\n      if (canUseVideoPresentation(video)) {\n        const presentation = new VideoPresentation(video, ctx);\n        this.fullscreen = new FullscreenPresentationAdapter(presentation);\n        this.pictureInPicture = new PIPPresentationAdapter(presentation);\n      } else if (canUsePictureInPicture(video)) {\n        this.pictureInPicture = new VideoPictureInPicture(video, ctx);\n      }\n    }, this.scope);\n  }\n  get type() {\n    return \"video\";\n  }\n  setup(ctx) {\n    super.setup(ctx);\n    if (canPlayHLSNatively(this.video)) {\n      new NativeHLSTextTracks(this.video, ctx);\n    }\n    ctx.textRenderers._attachVideo(this.video);\n    onDispose(() => {\n      ctx.textRenderers._attachVideo(null);\n    });\n    if (this.type === \"video\")\n      ctx.delegate._notify(\"provider-setup\", this);\n  }\n  /**\n   * The native HTML `<video>` element.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement}\n   */\n  get video() {\n    return this._media;\n  }\n}\n\nexport { VideoProvider };\n"],"names":[],"sourceRoot":""}
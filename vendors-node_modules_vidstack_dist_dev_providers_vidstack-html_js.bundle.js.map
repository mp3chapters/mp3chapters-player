{"version":3,"file":"vendors-node_modules_vidstack_dist_dev_providers_vidstack-html_js.bundle.js","mappings":";;;;;;;;;;;;;;AAAyE;;AAEzE;AACA;AACA;AACA;AACA;AACA,SAAS,wDAAW;AACpB;AACA;AACA;AACA;AACA,QAAQ,wDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAW;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEwB;;;;;;;;;;;;;;;;;;;AC1B0F;AAC4F;AAChJ;AACmB;;AAEjF;AACA;AACA;AACA;AACA,qBAAqB,+DAAc;AACnC;AACA;AACA;AACA,wBAAwB,2DAAO;AAC/B;AACA;AACA;AACA,IAAI,+DAAM;AACV,IAAI,+DAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO,mBAAmB,YAAY,uGAAuG,qBAAqB;AACvM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAS,IAAI,+DAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+DAAW;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,+DAAwB,yBAAyB,+DAAwB;AAC7J;AACA;AACA;AACA,cAAc,2DAAQ;AACtB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAU;AACtC;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,+DAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAS;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAY;AAChB;AACA,qBAAqB,WAAW;AAChC;AACA,QAAQ,+DAAa;AACrB;AACA,MAAM;AACN;AACA,wBAAwB,+DAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B","sources":["webpack://mp3chapters-player/./node_modules/vidstack/dist/dev/chunks/vidstack-IUoxhowK.js","webpack://mp3chapters-player/./node_modules/vidstack/dist/dev/providers/vidstack-html.js"],"sourcesContent":["import { i as isUndefined, a as isNumber } from './vidstack-KTx0QncX.js';\n\nclass RAFLoop {\n  constructor(_callback) {\n    this._callback = _callback;\n  }\n  _start() {\n    if (!isUndefined(this._id))\n      return;\n    this._loop();\n  }\n  _stop() {\n    if (isNumber(this._id))\n      window.cancelAnimationFrame(this._id);\n    this._id = void 0;\n  }\n  _loop() {\n    this._id = window.requestAnimationFrame(() => {\n      if (isUndefined(this._id))\n        return;\n      this._callback();\n      this._loop();\n    });\n  }\n}\n\nexport { RAFLoop as R };\n","import { i as isHLSSrc, g as getNumberOfDecimalPlaces, a as isMediaStream } from '../chunks/vidstack-ZF6S2MdD.js';\nimport { L as useDisposalBin, e as effect, o as onDispose, l as listenEvent, p as peek, M as isNil, D as DOMEvent, q as createScope, k as setAttribute, r as isString } from '../chunks/vidstack-KTx0QncX.js';\nimport { R as RAFLoop } from '../chunks/vidstack-IUoxhowK.js';\nimport { g as IS_SAFARI, L as ListSymbol } from '../chunks/vidstack-S5-ZnP-2.js';\n\nclass HTMLMediaEvents {\n  constructor(_provider, _ctx) {\n    this._provider = _provider;\n    this._ctx = _ctx;\n    this._disposal = useDisposalBin();\n    this._waiting = false;\n    this._attachedLoadStart = false;\n    this._attachedCanPlay = false;\n    this._timeRAF = new RAFLoop(this._onAnimationFrame.bind(this));\n    this._handlers = /* @__PURE__ */ new Map() ;\n    this._handleDevEvent = this._onDevEvent.bind(this) ;\n    this._attachInitialListeners();\n    effect(this._attachTimeUpdate.bind(this));\n    onDispose(this._onDispose.bind(this));\n  }\n  get _media() {\n    return this._provider.media;\n  }\n  get _notify() {\n    return this._ctx.delegate._notify;\n  }\n  _onDispose() {\n    this._attachedLoadStart = false;\n    this._attachedCanPlay = false;\n    this._timeRAF._stop();\n    this._disposal.empty();\n  }\n  /**\n   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress\n   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps\n   * resolve that by retrieving time updates in a request animation frame loop.\n   */\n  _onAnimationFrame() {\n    const newTime = this._media.currentTime;\n    if (this._ctx.$state.currentTime() !== newTime)\n      this._updateCurrentTime(newTime);\n  }\n  _attachInitialListeners() {\n    {\n      this._ctx.logger?.info(\"attaching initial listeners\");\n    }\n    this._attachEventListener(\"loadstart\", this._onLoadStart);\n    this._attachEventListener(\"abort\", this._onAbort);\n    this._attachEventListener(\"emptied\", this._onEmptied);\n    this._attachEventListener(\"error\", this._onError);\n    this._attachEventListener(\"volumechange\", this._onVolumeChange);\n    this._ctx.logger?.debug(\"attached initial media event listeners\");\n  }\n  _attachLoadStartListeners() {\n    if (this._attachedLoadStart)\n      return;\n    {\n      this._ctx.logger?.info(\"attaching load start listeners\");\n    }\n    this._disposal.add(\n      this._attachEventListener(\"loadeddata\", this._onLoadedData),\n      this._attachEventListener(\"loadedmetadata\", this._onLoadedMetadata),\n      this._attachEventListener(\"canplay\", this._onCanPlay),\n      this._attachEventListener(\"canplaythrough\", this._onCanPlayThrough),\n      this._attachEventListener(\"durationchange\", this._onDurationChange),\n      this._attachEventListener(\"play\", this._onPlay),\n      this._attachEventListener(\"progress\", this._onProgress),\n      this._attachEventListener(\"stalled\", this._onStalled),\n      this._attachEventListener(\"suspend\", this._onSuspend)\n    );\n    this._attachedLoadStart = true;\n  }\n  _attachCanPlayListeners() {\n    if (this._attachedCanPlay)\n      return;\n    {\n      this._ctx.logger?.info(\"attaching can play listeners\");\n    }\n    this._disposal.add(\n      this._attachEventListener(\"pause\", this._onPause),\n      this._attachEventListener(\"playing\", this._onPlaying),\n      this._attachEventListener(\"ratechange\", this._onRateChange),\n      this._attachEventListener(\"seeked\", this._onSeeked),\n      this._attachEventListener(\"seeking\", this._onSeeking),\n      this._attachEventListener(\"ended\", this._onEnded),\n      this._attachEventListener(\"waiting\", this._onWaiting)\n    );\n    this._attachedCanPlay = true;\n  }\n  _attachEventListener(eventType, handler) {\n    this._handlers.set(eventType, handler);\n    return listenEvent(\n      this._media,\n      eventType,\n      this._handleDevEvent \n    );\n  }\n  _onDevEvent(event2) {\n    this._ctx.logger?.debugGroup(`\\u{1F4FA} provider fired \\`${event2.type}\\``).labelledLog(\"Provider\", this._provider).labelledLog(\"Event\", event2).labelledLog(\"Media Store\", { ...this._ctx.$state }).dispatch();\n    this._handlers.get(event2.type)?.call(this, event2);\n  }\n  _updateCurrentTime(time, trigger) {\n    const detail = {\n      // Avoid errors where `currentTime` can have higher precision.\n      currentTime: Math.min(time, this._ctx.$state.seekableEnd()),\n      played: this._media.played\n    };\n    this._notify(\"time-update\", detail, trigger);\n  }\n  _onLoadStart(event2) {\n    if (this._media.networkState === 3) {\n      this._onAbort(event2);\n      return;\n    }\n    this._attachLoadStartListeners();\n    this._notify(\"load-start\", void 0, event2);\n  }\n  _onAbort(event2) {\n    this._notify(\"abort\", void 0, event2);\n  }\n  _onEmptied() {\n    this._notify(\"emptied\", void 0, event);\n  }\n  _onLoadedData(event2) {\n    this._notify(\"loaded-data\", void 0, event2);\n  }\n  _onLoadedMetadata(event2) {\n    this._attachCanPlayListeners();\n    this._notify(\"loaded-metadata\", void 0, event2);\n    if (IS_SAFARI && isHLSSrc(this._ctx.$state.source())) {\n      this._ctx.delegate._ready(this._getCanPlayDetail(), event2);\n    }\n  }\n  _getCanPlayDetail() {\n    return {\n      provider: peek(this._ctx.$provider),\n      duration: this._media.duration,\n      buffered: this._media.buffered,\n      seekable: this._media.seekable\n    };\n  }\n  _onPlay(event2) {\n    if (!this._ctx.$state.canPlay)\n      return;\n    this._notify(\"play\", void 0, event2);\n  }\n  _onPause(event2) {\n    if (this._media.readyState === 1 && !this._waiting)\n      return;\n    this._waiting = false;\n    this._timeRAF._stop();\n    this._notify(\"pause\", void 0, event2);\n  }\n  _onCanPlay(event2) {\n    this._ctx.delegate._ready(this._getCanPlayDetail(), event2);\n  }\n  _onCanPlayThrough(event2) {\n    if (this._ctx.$state.started())\n      return;\n    this._notify(\"can-play-through\", this._getCanPlayDetail(), event2);\n  }\n  _onPlaying(event2) {\n    this._waiting = false;\n    this._notify(\"playing\", void 0, event2);\n    this._timeRAF._start();\n  }\n  _onStalled(event2) {\n    this._notify(\"stalled\", void 0, event2);\n    if (this._media.readyState < 3) {\n      this._waiting = true;\n      this._notify(\"waiting\", void 0, event2);\n    }\n  }\n  _onWaiting(event2) {\n    if (this._media.readyState < 3) {\n      this._waiting = true;\n      this._notify(\"waiting\", void 0, event2);\n    }\n  }\n  _onEnded(event2) {\n    this._timeRAF._stop();\n    this._updateCurrentTime(this._media.duration, event2);\n    this._notify(\"end\", void 0, event2);\n    if (this._ctx.$state.loop()) {\n      const hasCustomControls = isNil(this._media.controls);\n      if (hasCustomControls)\n        this._media.controls = false;\n    }\n  }\n  _attachTimeUpdate() {\n    if (this._ctx.$state.paused()) {\n      listenEvent(this._media, \"timeupdate\", this._onTimeUpdate.bind(this));\n    }\n  }\n  _onTimeUpdate(event2) {\n    this._updateCurrentTime(this._media.currentTime, event2);\n  }\n  _onDurationChange(event2) {\n    if (this._ctx.$state.ended()) {\n      this._updateCurrentTime(this._media.duration, event2);\n    }\n    this._notify(\"duration-change\", this._media.duration, event2);\n  }\n  _onVolumeChange(event2) {\n    const detail = {\n      volume: this._media.volume,\n      muted: this._media.muted\n    };\n    this._notify(\"volume-change\", detail, event2);\n  }\n  _onSeeked(event2) {\n    this._updateCurrentTime(this._media.currentTime, event2);\n    this._notify(\"seeked\", this._media.currentTime, event2);\n    if (Math.trunc(this._media.currentTime) === Math.trunc(this._media.duration) && getNumberOfDecimalPlaces(this._media.duration) > getNumberOfDecimalPlaces(this._media.currentTime)) {\n      this._updateCurrentTime(this._media.duration, event2);\n      if (!this._media.ended) {\n        this._ctx.player.dispatch(\n          new DOMEvent(\"media-play-request\", {\n            trigger: event2\n          })\n        );\n      }\n    }\n  }\n  _onSeeking(event2) {\n    this._notify(\"seeking\", this._media.currentTime, event2);\n  }\n  _onProgress(event2) {\n    const detail = {\n      buffered: this._media.buffered,\n      seekable: this._media.seekable\n    };\n    this._notify(\"progress\", detail, event2);\n  }\n  _onSuspend(event2) {\n    this._notify(\"suspend\", void 0, event2);\n  }\n  _onRateChange(event2) {\n    this._notify(\"rate-change\", this._media.playbackRate, event2);\n  }\n  _onError(event2) {\n    const error = this._media.error;\n    if (!error)\n      return;\n    const detail = {\n      message: error.message,\n      code: error.code,\n      mediaError: error\n    };\n    this._notify(\"error\", detail, event2);\n  }\n}\n\nclass NativeAudioTracks {\n  constructor(_provider, _ctx) {\n    this._provider = _provider;\n    this._ctx = _ctx;\n    this._nativeTracks.onaddtrack = this._onAddNativeTrack.bind(this);\n    this._nativeTracks.onremovetrack = this._onRemoveNativeTrack.bind(this);\n    this._nativeTracks.onchange = this._onChangeNativeTrack.bind(this);\n    listenEvent(this._ctx.audioTracks, \"change\", this._onChangeTrack.bind(this));\n  }\n  get _nativeTracks() {\n    return this._provider.media.audioTracks;\n  }\n  _onAddNativeTrack(event) {\n    const _track = event.track;\n    if (_track.label === \"\")\n      return;\n    const audioTrack = {\n      id: _track.id + \"\",\n      label: _track.label,\n      language: _track.language,\n      kind: _track.kind,\n      selected: false\n    };\n    this._ctx.audioTracks[ListSymbol._add](audioTrack, event);\n    if (_track.enabled)\n      audioTrack.selected = true;\n  }\n  _onRemoveNativeTrack(event) {\n    const track = this._ctx.audioTracks.getById(event.track.id);\n    if (track)\n      this._ctx.audioTracks[ListSymbol._remove](track, event);\n  }\n  _onChangeNativeTrack(event) {\n    let enabledTrack = this._getEnabledNativeTrack();\n    if (!enabledTrack)\n      return;\n    const track = this._ctx.audioTracks.getById(enabledTrack.id);\n    if (track)\n      this._ctx.audioTracks[ListSymbol._select](track, true, event);\n  }\n  _getEnabledNativeTrack() {\n    return Array.from(this._nativeTracks).find((track) => track.enabled);\n  }\n  _onChangeTrack(event) {\n    const { current } = event.detail;\n    if (!current)\n      return;\n    const track = this._nativeTracks.getTrackById(current.id);\n    if (track) {\n      const prev = this._getEnabledNativeTrack();\n      if (prev)\n        prev.enabled = false;\n      track.enabled = true;\n    }\n  }\n}\n\nclass HTMLMediaProvider {\n  constructor(_media) {\n    this._media = _media;\n    this.scope = createScope();\n    this._currentSrc = null;\n  }\n  setup(ctx) {\n    new HTMLMediaEvents(this, ctx);\n    if (\"audioTracks\" in this.media)\n      new NativeAudioTracks(this, ctx);\n    onDispose(() => {\n      this._media.setAttribute(\"src\", \"\");\n      this._media.load();\n    });\n  }\n  get type() {\n    return \"\";\n  }\n  get media() {\n    return this._media;\n  }\n  get currentSrc() {\n    return this._currentSrc;\n  }\n  setPlaybackRate(rate) {\n    this._media.playbackRate = rate;\n  }\n  async play() {\n    return this._media.play();\n  }\n  async pause() {\n    return this._media.pause();\n  }\n  setMuted(muted) {\n    this._media.muted = muted;\n  }\n  setVolume(volume) {\n    this._media.volume = volume;\n  }\n  setCurrentTime(time) {\n    this._media.currentTime = time;\n  }\n  setPlaysinline(playsinline) {\n    setAttribute(this._media, \"playsinline\", playsinline);\n  }\n  async loadSource({ src, type }, preload) {\n    this._media.preload = preload || \"\";\n    if (isMediaStream(src)) {\n      this._media.srcObject = src;\n    } else {\n      this._media.srcObject = null;\n      this._media.src = isString(src) ? src : window.URL.createObjectURL(src);\n    }\n    this._media.load();\n    this._currentSrc = {\n      src,\n      type\n    };\n  }\n}\n\nexport { HTMLMediaProvider };\n"],"names":[],"sourceRoot":""}
{"version":3,"file":"node_modules_vidstack_dist_dev_providers_vidstack-video_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;AAA8G;AACsB;AAC7E;AAC+B;AAC9C;AACA;;AAExC;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAS;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAS;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,UAAU,2DAAe,cAAc;AACvC,UAAU,2DAAe;AACzB,UAAU,2DAAe;AACzB;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAW;AACf,IAAI,+DAAW;AACf;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAW;AACf;AACA;AACA,WAAW,+DAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAQ;AAClB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,gEAAiB;AAC7C;AACA;AACA;AACA,IAAI,+DAAM;AACV,UAAU,+DAAuB;AACjC;AACA;AACA;AACA,QAAQ,SAAS,+DAAsB;AACvC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAkB;AAC1B;AACA;AACA;AACA,IAAI,+DAAS;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEyB","sources":["webpack://mp3chapters-player/./node_modules/vidstack/dist/dev/providers/vidstack-video.js"],"sourcesContent":["import { o as onDispose, l as listenEvent, D as DOMEvent, s as scoped } from '../chunks/vidstack-KTx0QncX.js';\nimport { d as canUsePictureInPicture, e as canUseVideoPresentation, b as canPlayHLSNatively } from '../chunks/vidstack-S5-ZnP-2.js';\nimport { HTMLMediaProvider } from './vidstack-html.js';\nimport { b as TextTrack, T as TextTrackSymbol } from '../chunks/vidstack-Yx-0ZQdX.js';\nimport '../chunks/vidstack-ZF6S2MdD.js';\nimport '../chunks/vidstack-IUoxhowK.js';\n\nclass NativeHLSTextTracks {\n  constructor(_video, _ctx) {\n    this._video = _video;\n    this._ctx = _ctx;\n    _video.textTracks.onaddtrack = this._onAddTrack.bind(this);\n    onDispose(this._onDispose.bind(this));\n  }\n  _onAddTrack(event) {\n    const nativeTrack = event.track;\n    if (!nativeTrack || findTextTrackElement(this._video, nativeTrack))\n      return;\n    const track = new TextTrack({\n      id: nativeTrack.id,\n      kind: nativeTrack.kind,\n      label: nativeTrack.label,\n      language: nativeTrack.language,\n      type: \"vtt\"\n    });\n    track[TextTrackSymbol._native] = { track: nativeTrack };\n    track[TextTrackSymbol._readyState] = 2;\n    track[TextTrackSymbol._nativeHLS] = true;\n    let lastIndex = 0;\n    const onCueChange = (event2) => {\n      if (!nativeTrack.cues)\n        return;\n      for (let i = lastIndex; i < nativeTrack.cues.length; i++) {\n        track.addCue(nativeTrack.cues[i], event2);\n        lastIndex++;\n      }\n    };\n    onCueChange(event);\n    nativeTrack.oncuechange = onCueChange;\n    this._ctx.textTracks.add(track, event);\n    track.setMode(nativeTrack.mode, event);\n  }\n  _onDispose() {\n    this._video.textTracks.onaddtrack = null;\n    for (const track of this._ctx.textTracks) {\n      const nativeTrack = track[TextTrackSymbol._native]?.track;\n      if (nativeTrack?.oncuechange)\n        nativeTrack.oncuechange = null;\n    }\n  }\n}\nfunction findTextTrackElement(video, track) {\n  return Array.from(video.children).find((el) => el.track === track);\n}\n\nclass VideoPictureInPicture {\n  constructor(_video, _media) {\n    this._video = _video;\n    this._media = _media;\n    this._onChange = (active, event) => {\n      this._media.delegate._notify(\"picture-in-picture-change\", active, event);\n    };\n    listenEvent(this._video, \"enterpictureinpicture\", this._onEnter.bind(this));\n    listenEvent(this._video, \"leavepictureinpicture\", this._onExit.bind(this));\n  }\n  get active() {\n    return document.pictureInPictureElement === this._video;\n  }\n  get supported() {\n    return canUsePictureInPicture(this._video);\n  }\n  async enter() {\n    return this._video.requestPictureInPicture();\n  }\n  exit() {\n    return document.exitPictureInPicture();\n  }\n  _onEnter(event) {\n    this._onChange(true, event);\n  }\n  _onExit(event) {\n    this._onChange(false, event);\n  }\n}\n\nclass VideoPresentation {\n  constructor(_video, _media) {\n    this._video = _video;\n    this._media = _media;\n    this._mode = \"inline\";\n    listenEvent(this._video, \"webkitpresentationmodechanged\", this._onModeChange.bind(this));\n  }\n  get _supported() {\n    return canUseVideoPresentation(this._video);\n  }\n  async _setPresentationMode(mode) {\n    if (this._mode === mode)\n      return;\n    this._video.webkitSetPresentationMode(mode);\n  }\n  _onModeChange(event) {\n    const prevMode = this._mode;\n    this._mode = this._video.webkitPresentationMode;\n    {\n      this._media.logger?.infoGroup(\"presentation mode change\").labelledLog(\"Mode\", this._mode).labelledLog(\"Event\", event).dispatch();\n    }\n    this._media.player?.dispatch(\n      new DOMEvent(\"video-presentation-change\", {\n        detail: this._mode,\n        trigger: event\n      })\n    );\n    [\"fullscreen\", \"picture-in-picture\"].forEach((type) => {\n      if (this._mode === type || prevMode === type) {\n        this._media.delegate._notify(`${type}-change`, this._mode === type, event);\n      }\n    });\n  }\n}\nclass FullscreenPresentationAdapter {\n  constructor(_presentation) {\n    this._presentation = _presentation;\n  }\n  get active() {\n    return this._presentation._mode === \"fullscreen\";\n  }\n  get supported() {\n    return this._presentation._supported;\n  }\n  async enter() {\n    this._presentation._setPresentationMode(\"fullscreen\");\n  }\n  async exit() {\n    this._presentation._setPresentationMode(\"inline\");\n  }\n}\nclass PIPPresentationAdapter {\n  constructor(_presentation) {\n    this._presentation = _presentation;\n  }\n  get active() {\n    return this._presentation._mode === \"picture-in-picture\";\n  }\n  get supported() {\n    return this._presentation._supported;\n  }\n  async enter() {\n    this._presentation._setPresentationMode(\"picture-in-picture\");\n  }\n  async exit() {\n    this._presentation._setPresentationMode(\"inline\");\n  }\n}\n\nclass VideoProvider extends HTMLMediaProvider {\n  constructor(video, ctx) {\n    super(video);\n    this.$$PROVIDER_TYPE = \"VIDEO\";\n    scoped(() => {\n      if (canUseVideoPresentation(video)) {\n        const presentation = new VideoPresentation(video, ctx);\n        this.fullscreen = new FullscreenPresentationAdapter(presentation);\n        this.pictureInPicture = new PIPPresentationAdapter(presentation);\n      } else if (canUsePictureInPicture(video)) {\n        this.pictureInPicture = new VideoPictureInPicture(video, ctx);\n      }\n    }, this.scope);\n  }\n  get type() {\n    return \"video\";\n  }\n  setup(ctx) {\n    super.setup(ctx);\n    if (canPlayHLSNatively(this.video)) {\n      new NativeHLSTextTracks(this.video, ctx);\n    }\n    ctx.textRenderers._attachVideo(this.video);\n    onDispose(() => {\n      ctx.textRenderers._attachVideo(null);\n    });\n    if (this.type === \"video\")\n      ctx.delegate._notify(\"provider-setup\", this);\n  }\n  /**\n   * The native HTML `<video>` element.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement}\n   */\n  get video() {\n    return this._media;\n  }\n}\n\nexport { VideoProvider };\n"],"names":[],"sourceRoot":""}